run_simu_stats_for_sim_data_input 01
    # 
    # Aim:
    #       This program aims at analyzing galaxies' Monte Carlo simulation
    #       and derive correction recipes for fluxes and errors. 
    #       Here we do not use galfit flux errors because their histogram
    #       of ((S_in-S_out)/error_S_out) are far from Gaussian. 
    #       So we should derive flux errors purely based on statistics without prior. 
    # 
    # Usage:
    #       echo "macro read run_simu_stats_almacosmos_2D.sm run_simu_stats_for_sim_data_input simu_data_input.txt" | sm
    # 
    
    if(!$?1) {
        print 'Usage: \n' {} 
        print '       macro read run_simu_stats_almacosmos_2D.sm\n' {}
        print '       run_simu_stats_for_sim_data_input simu_data_input.txt\n' {}
        return
    }
    
    load rfile.sm
    rfile $1
    # 
    # check variables 
    #if(!is_vector(Area)) {
    #    # Area is the source convolved area in unit of beam area
    #    set Area = Xf*0.0 + 1.0
    #}
    if(!is_vector(fres)) {
        # fres is the abs(sum(residual_image_pixels_within_0.5_arcsec_aperture))
        set fres = Xf*0.0 + 0.0
    }
    # 
    # check variables 
    define check_columns 1
    foreach var {id Xf f snr_total fpeak noise fres Maj Min beam_maj beam_min sim_alma_image_STR sim_repetition_STR} {
        if(!is_vector($var)) {
            define check_columns 0
            print 'Column $var was not found in the input file!\n' {}
        }
    }
    if($check_columns==0) {return}
    # 
    #load crabStat.sm
    #load crabPlot.sm
    #load crabPlotHistogram.sm
    #load astroPhot.sm
    # 
    # define output dir
    define outdir "sim_diagram_output_almacosmos_2D"
    # 
    # mkdir
    !mkdir $outdir 2>/dev/null
    # 
    # filter bad sources which have zero fpeak (at the edge of the image)
    set filter = (Xf>=1.0*noise && fpeak>=2.0*noise)
    foreach var {id Xf f snr_total fpeak noise fres Maj Min beam_maj beam_min sim_alma_image_STR sim_repetition_STR} {
        set $var = $var if(filter)
    }
    # 
    # set more useful variables
    set df = f / snr_total
    set df = (df<noise) ? noise : df
    set fpeakSNR = fpeak/noise
    set MajBeam = Maj/beam_maj
    # 
    # 
    # 
    # Analyzing sources
    echo ""
    echo "Analyzing "$(dimen(Xf))" sources"
    echo ""
    # 
    stats_med noise noise_median noise_kurt
    echo "noise_median = "$noise_median
    echo ""
    # 
    # 
    # 
    # store uncorr0
    set f_uncorr0 = f
    set fpeak_uncorr0 = fpeak
    set df_uncorr0 = df
    set fpeakSNR_uncorr0 = fpeak/noise
    set ftotalSNR_uncorr0 = f/df
    # 
    set fbias = f*0.0
    set ferr_L68 = f*0.0 + 1e10
    set ferr_H68 = f*0.0 + 1e10
    set cell_id = f*0-99
    # 
    # 
    # 
    # set bin by which parameters
    set bin_pars = <"MajBeam" "fpeakSNR">
    set bin_par1_edges = {0.00 0.50 1.00 1.50 2.00 2.50 3.00 3.50 5.00}
    set bin_par2_edges = {2.0 2.5 3.0 3.5 4.0 5.0 7.0 10. 20. 50. 100}
    declare bin_cell_dim 0.d
    set bin_cell_numb = 1
    do i = 1, dimen(bin_pars) {
        # get min max
        set bin_par$i""_array = $(bin_pars[$i-1])
        vecminmax bin_par$i""_array tmin tmax
        set bin_par$i""_min = $tmin
        set bin_par$i""_max = $tmax
        # get bin edges
        if(!is_vector(bin_par$i""_edges)) {
            set bin_par$i""_edges = $tmin,$tmax,$(($tmax-$tmin)/6)
        }
        print 'Bin by $(bin_pars[$i-1]), min max: $tmin $tmax' {}
        if($tmin>=$tmax) {
            print '\n' {}
            print 'Error! Could not determine valid min and max for data array $(bin_pars[$i-1])! Maybe this data array contains no valid value!\n' {}
            exit
        } else {
            print ', bin edges:' {}
            do k = 0, dimen(bin_par$i""_edges)-1 {
                print ' $(bin_par$i""_edges[$k])' {}
            }
        }
        print ' ($(dimen(bin_par$i""_edges)-1))\n' {}
        set bin_cell_dim = bin_cell_dim concat $(dimen(bin_par$i""_edges)-1) # note that -1 is because edge list has one more element than cell list. 
        set bin_cell_numb = bin_cell_numb * $(dimen(bin_par$i""_edges)-1) # note that -1 is because edge list has one more element than cell list. 
    }
    print 'Bin cell dimension:' {}
    do i = 1, dimen(bin_pars) {
        print ' $(bin_cell_dim[$i-1])' {}
    }
    print '; bin cell number: $(bin_cell_numb)' {}
    print '\n' {}
    # 
    # 
    # 
    # 
    # 
    # 
    # print separator
    print '\n--------------------------------------------------------------------------------\n\n' {}
    # 
    # 
    # 
    # 
    # 
    # 
    # loop each bin cell to compute fbias
    set do_overwrite_cell_median_function = 0
    if(!is_file($outdir"/datatable_cell_median_function.txt") || do_overwrite_cell_median_function == 1) {
        define icount 0
        do i = 1, dimen(bin_pars) {
            define i$i 1 # here i$i starts from 1 because our looping array is bin_edges, which has one more element than the bin number. 
        }
        while { $icount <= bin_cell_numb } {
            # 
            # prepare output
            if($icount == 0) {
                if(is_file($outdir"/datatable_cell_parameters.txt")) {
                    !mv $outdir"/datatable_cell_parameters.txt" $outdir"/datatable_cell_parameters.txt.backup"
                }
                print $outdir"/datatable_cell_parameters.txt" '\# bin_cell_id_par' {}
                # 
                do i = 1, dimen(bin_pars) {
                    print +$outdir"/datatable_cell_parameters.txt" '\tpar_$i""_str\tpar_$i""_lo\tpar_$i""_hi' {}
                }
                print +$outdir"/datatable_cell_parameters.txt" '\n\#\n' {}
            }
            # 
            # current cell
            print 'Current cell $($icount+1):' {}
            print +$outdir"/datatable_cell_parameters.txt" '$($icount+1)' {}
            do i = 1, dimen(bin_pars) {
                print '\t$(bin_pars[$i-1]) $(bin_par$i""_edges[$i$i-1])-$(bin_par$i""_edges[$i$i])' {}
                print +$outdir"/datatable_cell_parameters.txt" '\t$(bin_pars[$i-1])\t$(bin_par$i""_edges[$i$i-1])\t$(bin_par$i""_edges[$i$i])' {}
            }
            print +$outdir"/datatable_cell_parameters.txt" '\n' {}
            # 
            # select data points in each bin
            set bin_selection = Xf*0+1
            do i = 1, dimen(bin_pars) {
                set bin_selection = $(bin_pars[$i-1]) < $(bin_par$i""_edges[$i$i-1]) ? 0 : bin_selection
                set bin_selection = $(bin_pars[$i-1]) >= $(bin_par$i""_edges[$i$i]) ? 0 : bin_selection
            }
            print ', $(sum(bin_selection)) dp' {}
            # 
            # check data points
            if(sum(bin_selection)>=3) {
                # 
                # get bin (Xf-f)/Xf data
                set bin_data = (Xf-f)/Xf if(bin_selection==1)
                set bin_data_indices = 0,dimen(Xf)-1
                set bin_data_indices = bin_data_indices if(bin_selection==1)
                # 
                # calc bin par mean
                do i = 1, dimen(bin_pars) {
                    set bin_cell_par_$i""_data = $(bin_pars[$i-1]) if(bin_selection==1)
                    stats bin_cell_par_$i""_data bin_cell_par_x_mean bin_cell_par_x_sigma bin_cell_par_x_kurt
                    set bin_cell_par_$i""_mean = $bin_cell_par_x_mean
                }
                # 
                # calc (Xf-f)/Xf mean and median
                calc_mean_median bin_data 10.0
                print ',\t(Xf-f)/Xf mean $(calc_bin_mean) med $(calc_bin_median)' {}
                # 
                # store calc_bin_median and calc_bin_mean
                set bin_cell_median = calc_bin_median
                set bin_cell_mean = calc_bin_mean
                # 
                # store bin_cell_id and cell_id
                set bin_cell_id = float($icount+1) # the cell_id starts from 1, so here +1. 
                set cell_id[bin_data_indices] = ($icount+1) # the cell_id starts from 1, so here +1. 
                # 
                # print to "datatable_cell_median.txt"
                if(bin_cell_id==1) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_median.txt" '%15.0f %23g\n' {bin_cell_id bin_cell_median}
                } else {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_median.txt" '%15.0f %23g\n' {bin_cell_id bin_cell_median}
                    define print_noheader 0
                }
                # 
                # print to "datatable_cell_mean.txt"
                if(bin_cell_id==1) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_mean.txt" '%15.0f %23g\n' {bin_cell_id bin_cell_mean}
                } else {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_mean.txt" '%15.0f %23g\n' {bin_cell_id bin_cell_mean}
                    define print_noheader 0
                }
                # 
                # print to "datatable_cell_par_x_mean.txt"
                if(bin_cell_id==1) {
                    do i = 1, dimen(bin_pars) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_par_"$i"_mean.txt" '%15.0f %23g\n' <bin_cell_id bin_cell_par_$i""_mean>
                    }
                } else {
                    do i = 1, dimen(bin_pars) {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_par_"$i"_mean.txt" '%15.0f %23g\n' <bin_cell_id bin_cell_par_$i""_mean>
                    define print_noheader 0
                    }
                }
                # 
                # debug bin_data
                print $outdir"/debug_data_cell_id_"$(bin_cell_id)".txt" {bin_data}
            }
            # 
            # 
            print '\n' {}
            # 
            # next cell
            define icount $($icount+1)
            if($icount < bin_cell_numb) {
                define i 1
                define i$i $($i$i+1)
                do i = 1, dimen(bin_pars) {
                    if($i$i > bin_cell_dim[$i-1]) {
                        #<NOTE># here $i$i > dim is because we use $i$i, which starts from 1, for the bin edge array, which has one more element than the bin array. 
                        define i$i $($i$i-bin_cell_dim[$i-1])
                        if($i < dimen(bin_pars)) {
                            #<NOTE># $i and i$i starts from 1
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # read cell median from "datatable_cell_median.txt"
        data $outdir"/datatable_cell_median.txt"
        read {bin_cell_id 1 bin_cell_median 2}
        # 
        # read cell parameters from "datatable_cell_parameters.txt"
        #do i = 1, dimen(bin_pars) {
        #    set bin_cell_par_$i = bin_cell_median*0.0
        #}
        #do k = 0, dimen(bin_cell_id)-1 {
        #    verbose 0
        #    data $outdir"/datatable_cell_parameters.txt"
        #    lines $(bin_cell_id[$k]+2) $(bin_cell_id[$k]+2)
        #    # here +2 considers two commented header lines. 
        #    read <bin_cell_id_in 1>
        #    if(bin_cell_id_in!=bin_cell_id[$k]) {
        #        echo "Error! bin_cell_id_in!=bin_cell_id[$k]"
        #        echo "bin_cell_id_in = "$(bin_cell_id_in)
        #        echo "bin_cell_id[$k] = "$(bin_cell_id[$k])
        #        exit
        #    }
        #    do i = 1, dimen(bin_pars) {
        #        read <bin_cell_par_$i""_lo $(3*$i) bin_cell_par_$i""_hi $(3*$i+1)>
        #        # columns are : cell_id, par_1_str, par_1_lo, par_1_hi, par_2_str, par_2_lo, par_2_hi, .. --- so the column number is 3*$i
        #        set bin_cell_par_$i[$k] = ((bin_cell_par_$i""_lo+bin_cell_par_$i""_hi)/2.0)
        #        # see our fitted function form above
        #    }
        #    verbose 1
        #}
        # 
        # read cell parameters from "datatable_cell_par_"$i"_mean.txt"
        do i = 1, dimen(bin_pars) {
            data $outdir"/datatable_cell_par_"$i"_mean.txt" read <bin_cell_par_$i 2.f>
        }
        # 
        # print 
        print $outdir"/datatable_cell_median_with_par.txt" '%15.0f %25g %25g %25g\n' {bin_cell_id bin_cell_median bin_cell_par_1 bin_cell_par_2}
        # 
        # 
        # 20171119
        # fit (Xf-f)/Xf median as a function of par1, par2, ..., parN
        # Y = a0 / par1**a1 / par2**a2 / ...
        declare fit_a0 0.f
        set fit_range_a0 = 2.0,-12.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, dimen(bin_pars) {
            declare fit_a$i 0.f
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.f
        # 
        # sample fitting function parameter space
        define icount 0
        define i0 0
        do i = 1, dimen(bin_pars) {
            define i$i 0 # here we just use i$i starting from 0
        }
        while { $icount <= fit_count_numb } {
            set _fit_a0 = fit_range_a0[$i0]
            do i = 1, dimen(bin_pars) {
                set _fit_a$i = fit_range_a$i[$i$i]
            }
            set _fit_chi2 = 0.0
            set _fit_y = _fit_a0
            do i = 1, dimen(bin_pars) {
                set _fit_y = _fit_y / ((bin_cell_par_$i)**_fit_a$i)
            }
            set _fit_chi2 = _fit_chi2 + sum((bin_cell_median-_fit_y)**2) # fitting (A/x**B) equation
            # 
            # store chi2
            set fit_a0 = fit_a0 concat _fit_a0
            set fit_chi2 = fit_chi2 concat _fit_chi2
            do i = 1, dimen(bin_pars) {
                set fit_a$i = fit_a$i concat _fit_a$i
            }
            # 
            # next fit parameter grid point
            define icount $($icount+1)
            if($icount < fit_count_numb) {
                define i 0 # here we need to loop a0, a1, a2, ..., aNpar
                define i$i $($i$i+1)
                do i = 0, dimen(bin_pars) {
                    if($i$i >= dimen(fit_range_a$i)) {
                        #<NOTE># here $i$i >= dim is because $i$i starts from 0.
                        define i$i $($i$i-dimen(fit_range_a$i))
                        if($i < dimen(bin_pars)) {
                            #<NOTE># $i starts from 1, but here $i$i starts from 0. 
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # sort chi2 and get best-fit function parameters
        load wfile.sm
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, dimen(bin_pars) {
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        wfile $outdir"/datatable_cell_median_function_fitting_chi2.txt"
        # 
        set fit_sort = fit_chi2
        sort <fit_sort fit_a0>
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, dimen(bin_pars) {
            set fit_sort = fit_chi2
            sort <fit_sort fit_a$i>
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        set fit_sort = fit_chi2
        sort <fit_sort fit_chi2>
        wfile $outdir"/datatable_cell_median_function_fitting_chi2_sorted.txt"
        # 
        # write best-fit function parameters
        set fit_chi2 = fit_chi2[0]
        set fit_a0 = fit_a0[0]
        do i = 1, dimen(bin_pars) {
            set fit_a$i = fit_a$i[0]
        }
        define print_noheader 1
        print  $outdir"/datatable_cell_median_function.txt" 'set fit_a0 = %0.20g\n' <fit_a0>
        print +$outdir"/datatable_cell_median_function.txt" 'set fit_y = fit_a0\n' {}
        do i = 1, dimen(bin_pars) {
        print +$outdir"/datatable_cell_median_function.txt" '\#set data_x$i = $(bin_pars[$i-1])\n' {}
        print +$outdir"/datatable_cell_median_function.txt" 'set fit_a$i = %0.20g\n' <fit_a$i>
        print +$outdir"/datatable_cell_median_function.txt" 'set fit_y = fit_y / (data_x$i**fit_a$i)\n' {}
        }
        define print_noheader 0
        !cat $outdir"/datatable_cell_median_function.txt"
    }
    # 
    # 
    # 
    # 
    # 
    # 
    # print separator
    print '\n--------------------------------------------------------------------------------\n\n' {}
    # 
    # 
    # 
    # 
    # 
    # 
    # loop each bin cell again to compute df_corr
    set do_overwrite_cell_sigma_function = 0
    if(!is_file($outdir"/datatable_cell_sigma_L68_function.txt") || do_overwrite_cell_sigma_function == 1) {
        define icount 0
        do i = 1, dimen(bin_pars) {
            define i$i 1 # here i$i starts from 1 because our looping array is bin_edges, which has one more element than the bin number. 
        }
        while { $icount <= bin_cell_numb } {
            # 
            # current cell
            print 'Current cell $($icount+1):' {}
            do i = 1, dimen(bin_pars) {
                print '\t$(bin_pars[$i-1]) $(bin_par$i""_edges[$i$i-1])-$(bin_par$i""_edges[$i$i])' {}
            }
            # 
            # select data points in each bin
            set bin_selection = Xf*0+1
            do i = 1, dimen(bin_pars) {
                set bin_selection = $(bin_pars[$i-1]) < $(bin_par$i""_edges[$i$i-1]) ? 0 : bin_selection
                set bin_selection = $(bin_pars[$i-1]) >= $(bin_par$i""_edges[$i$i]) ? 0 : bin_selection
            }
            print ', $(sum(bin_selection)) dp' {}
            # 
            # check data points
            if(sum(bin_selection)>=3) {
                # 
                # bin (Xf-f)/Xf
                set bin_data = (Xf-f)/Xf if(bin_selection==1)
                set bin_data_indices = 0,dimen(Xf)-1
                set bin_data_indices = bin_data_indices if(bin_selection==1)
                # 
                # calc (Xf-f)/Xf mean and median
                calc_mean_median bin_data 10.0
                print ',\t(Xf-f)/Xf mean $(calc_bin_mean) med $(calc_bin_median)' {}
                # 
                # correct (Xf-f)/Xf median
                do i = 1, dimen(bin_pars) {
                    set data_x$i = $(bin_pars[$i-1]) if(bin_selection==1)
                }
                input $outdir"/datatable_cell_median_function.txt"
                #--> output fit_y
                # 
                # derive flux density bias
                #     (Xf-f)/Xf = calc_bin_median
                # =>  Xf = f/(1-calc_bin_median)
                # =>  fbias = (Xf-f) = f*(1/(1-calc_bin_median)-1) = f * (calc_bin_median/(1-calc_bin_median))
                set bin_cell_median = fit_y
                set fbias[bin_data_indices] = f[bin_data_indices] * (bin_cell_median/(1-bin_cell_median))
                set f[bin_data_indices] = f[bin_data_indices] + fbias[bin_data_indices]
                # 
                # 
                # 
                # calc (Xf-f)/df sigma after applying fbias correction
                set bin_data = (Xf[bin_data_indices]-f[bin_data_indices])/Xf[bin_data_indices]
                calc_asymmetric_scatters bin_data 3.0
                print ',\t(Xf-f)/df sig $(asym_bin_scatter_L68) $(asym_bin_scatter_H68)' {}
                # 
                # derive flux density error
                #     (S_in - S_out) / S_in = sig
                # ..  (S_in - S_out) / err = 1.0
                # =>  err = S_in * sig
                # ..  S_out = S_in
                # =>  err = S_out * sig
                set bin_cell_sigma_L68 = asym_bin_scatter_L68
                set bin_cell_sigma_H68 = asym_bin_scatter_H68
                set ferr_L68[bin_data_indices] = f[bin_data_indices] * (asym_bin_scatter_L68)
                set ferr_H68[bin_data_indices] = f[bin_data_indices] * (asym_bin_scatter_H68)
                # 
                # store bin_cell_id and cell_id
                set bin_cell_id = float($icount+1) # the cell_id starts from 1, so here +1. 
                set cell_id[bin_data_indices] = ($icount+1) # the cell_id starts from 1, so here +1. 
                # 
                # print to "datatable_cell_sigma.txt"
                if(bin_cell_id==1) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_sigma_L68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_L68}
                } else {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_sigma_L68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_L68}
                    define print_noheader 0
                }
                # 
                # print to "datatable_cell_sigma.txt"
                if(bin_cell_id==1) {
                    define print_noheader 0
                    print $outdir"/datatable_cell_sigma_H68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_H68}
                } else {
                    define print_noheader 1
                    print +$outdir"/datatable_cell_sigma_H68.txt" '%15.0f %25g\n' {bin_cell_id bin_cell_sigma_H68}
                    define print_noheader 0
                }
                # 
                # debug bin_data
                print $outdir"/debug_data_fbias_corrected_cell_id_"$(bin_cell_id)".txt" {bin_data}
            }
            # 
            # 
            print '\n' {}
            # 
            # next cell
            define icount $($icount+1)
            if($icount < bin_cell_numb) {
                define i 1
                define i$i $($i$i+1)
                do i = 1, dimen(bin_pars) {
                    if($i$i > bin_cell_dim[$i-1]) {
                        #<NOTE># here $i$i > dim is because we use $i$i, which starts from 1, for the bin edge array, which has one more element than the bin array. 
                        define i$i $($i$i-bin_cell_dim[$i-1])
                        if($i < dimen(bin_pars)) {
                            #<NOTE># $i and i$i starts from 1
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # read cell median from "datatable_cell_sigma_L68.txt"
        data $outdir"/datatable_cell_sigma_L68.txt"
        read {bin_cell_id 1 bin_cell_sigma_L68 2}
        # read cell parameters from "datatable_cell_par_"$i"_mean.txt"
        do i = 1, dimen(bin_pars) {
            data $outdir"/datatable_cell_par_"$i"_mean.txt" read <bin_cell_par_$i 2.f>
        }
        print $outdir"/datatable_cell_sigma_L68_with_par.txt" '%15.0f %25g %25g %25g\n' {bin_cell_id bin_cell_sigma_L68 bin_cell_par_1 bin_cell_par_2}
        # 
        # filter invalid (zero) data points
        set coo = (bin_cell_sigma_L68>0)
        foreach var {bin_cell_id bin_cell_sigma_L68 bin_cell_par_1 bin_cell_par_2} {
            set $var = $var if(coo)
        }
        # 
        # 
        # 20171119
        # fit (Xf-f)/Xf sigma_L68 as a function of par1, par2, ..., parN
        # Y = a0 / par1**a1 / par2**a2 / ...
        declare fit_a0 0.f
        set fit_range_a0 = 2.0,-10.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, dimen(bin_pars) {
            declare fit_a$i 0.f
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.f
        # 
        # sample fitting function parameter space
        define icount 0
        define i0 0
        do i = 1, dimen(bin_pars) {
            define i$i 0 # here we just use i$i starting from 0
        }
        while { $icount <= fit_count_numb } {
            set _fit_a0 = fit_range_a0[$i0]
            do i = 1, dimen(bin_pars) {
                set _fit_a$i = fit_range_a$i[$i$i]
            }
            set _fit_chi2 = 0.0
            set _fit_y = _fit_a0
            do i = 1, dimen(bin_pars) {
                set _fit_y = _fit_y / ((bin_cell_par_$i)**_fit_a$i)
            }
            set _fit_chi2 = _fit_chi2 + sum((bin_cell_sigma_L68-_fit_y)**2) # fitting (A/x**B) equation
            # 
            # store chi2
            set fit_a0 = fit_a0 concat _fit_a0
            set fit_chi2 = fit_chi2 concat _fit_chi2
            do i = 1, dimen(bin_pars) {
                set fit_a$i = fit_a$i concat _fit_a$i
            }
            # 
            # next fit parameter grid point
            define icount $($icount+1)
            if($icount < fit_count_numb) {
                define i 0 # here we need to loop a0, a1, a2, ..., aNpar
                define i$i $($i$i+1)
                do i = 0, dimen(bin_pars) {
                    if($i$i >= dimen(fit_range_a$i)) {
                        #<NOTE># here $i$i >= dim is because $i$i starts from 0.
                        define i$i $($i$i-dimen(fit_range_a$i))
                        if($i < dimen(bin_pars)) {
                            #<NOTE># $i starts from 1, but here $i$i starts from 0. 
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # sort chi2 and get best-fit function parameters
        load wfile.sm
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, dimen(bin_pars) {
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        wfile $outdir"/datatable_cell_sigma_L68_function_fitting_chi2.txt"
        # 
        set fit_sort = fit_chi2
        sort <fit_sort fit_a0>
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, dimen(bin_pars) {
            set fit_sort = fit_chi2
            sort <fit_sort fit_a$i>
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        set fit_sort = fit_chi2
        sort <fit_sort fit_chi2>
        wfile $outdir"/datatable_cell_sigma_L68_function_fitting_chi2_sorted.txt"
        # 
        # write best-fit function parameters
        set fit_chi2 = fit_chi2[0]
        set fit_a0 = fit_a0[0]
        do i = 1, dimen(bin_pars) {
            set fit_a$i = fit_a$i[0]
        }
        define print_noheader 1
        print  $outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_a0 = %0.20g\n' <fit_a0>
        print +$outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_y = fit_a0\n' {}
        do i = 1, dimen(bin_pars) {
        print +$outdir"/datatable_cell_sigma_L68_function.txt" '\#set data_x$i = $(bin_pars[$i-1])\n' {}
        print +$outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_a$i = %0.20g\n' <fit_a$i>
        print +$outdir"/datatable_cell_sigma_L68_function.txt" 'set fit_y = fit_y / (data_x$i**fit_a$i)\n' {}
        }
        define print_noheader 0
        !cat $outdir"/datatable_cell_sigma_L68_function.txt"
        # 
        # 
        # 
        # 
        # 
        # 
        # fit bin_cell_sigma_H68
        declare fit_a0 0.f
        set fit_range_a0 = 2.0,-10.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, dimen(bin_pars) {
            declare fit_a$i 0.f
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.f
        # read cell median from "datatable_cell_sigma_H68.txt"
        data $outdir"/datatable_cell_sigma_H68.txt"
        read {bin_cell_id 1 bin_cell_sigma_H68 2}
        # read cell parameters from "datatable_cell_par_"$i"_mean.txt"
        do i = 1, dimen(bin_pars) {
            data $outdir"/datatable_cell_par_"$i"_mean.txt" read <bin_cell_par_$i 2.f>
        }
        print $outdir"/datatable_cell_sigma_H68_with_par.txt" '%15.0f %25g %25g %25g\n' {bin_cell_id bin_cell_sigma_H68 bin_cell_par_1 bin_cell_par_2}
        # 
        # filter invalid (zero) data points
        set coo = (bin_cell_sigma_H68>0)
        foreach var {bin_cell_id bin_cell_sigma_H68 bin_cell_par_1 bin_cell_par_2} {
            set $var = $var if(coo)
        }
        # 
        # 
        # 20171119
        # fit (Xf-f)/Xf sigma_H68 as a function of par1, par2, ..., parN
        # Y = a0 / par1**a1 / par2**a2 / ...
        declare fit_a0 0.f
        set fit_range_a0 = 2.0,-10.0,-0.5 #<TODO># Tune fit range
        set fit_count_numb = dimen(fit_range_a0)
        do i = 1, dimen(bin_pars) {
            declare fit_a$i 0.f
            set fit_range_a$i = -5.0,5.0,0.2 #<TODO># Tune fit range
            set fit_count_numb = fit_count_numb * dimen(fit_range_a$i)
        }
        declare fit_chi2 0.f
        # 
        # sample fitting function parameter space
        define icount 0
        define i0 0
        do i = 1, dimen(bin_pars) {
            define i$i 0 # here we just use i$i starting from 0
        }
        while { $icount <= fit_count_numb } {
            set _fit_a0 = fit_range_a0[$i0]
            do i = 1, dimen(bin_pars) {
                set _fit_a$i = fit_range_a$i[$i$i]
            }
            set _fit_chi2 = 0.0
            set _fit_y = _fit_a0
            do i = 1, dimen(bin_pars) {
                set _fit_y = _fit_y / ((bin_cell_par_$i)**_fit_a$i)
            }
            set _fit_chi2 = _fit_chi2 + sum((bin_cell_sigma_H68-_fit_y)**2) # fitting (A/x**B) equation
            # 
            # store chi2
            set fit_a0 = fit_a0 concat _fit_a0
            set fit_chi2 = fit_chi2 concat _fit_chi2
            do i = 1, dimen(bin_pars) {
                set fit_a$i = fit_a$i concat _fit_a$i
            }
            # 
            # next fit parameter grid point
            define icount $($icount+1)
            if($icount < fit_count_numb) {
                define i 0 # here we need to loop a0, a1, a2, ..., aNpar
                define i$i $($i$i+1)
                do i = 0, dimen(bin_pars) {
                    if($i$i >= dimen(fit_range_a$i)) {
                        #<NOTE># here $i$i >= dim is because $i$i starts from 0.
                        define i$i $($i$i-dimen(fit_range_a$i))
                        if($i < dimen(bin_pars)) {
                            #<NOTE># $i starts from 1, but here $i$i starts from 0. 
                            define i$($i+1) $($i$($i+1)+1)
                        }
                    }
                }
            }
        }
        # 
        # sort chi2 and get best-fit function parameters
        load wfile.sm
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, dimen(bin_pars) {
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        wfile $outdir"/datatable_cell_sigma_H68_function_fitting_chi2.txt"
        # 
        set fit_sort = fit_chi2
        sort <fit_sort fit_a0>
        set wfile_vectors = {fit_chi2 fit_a0}
        do i = 1, dimen(bin_pars) {
            set fit_sort = fit_chi2
            sort <fit_sort fit_a$i>
            set wfile_vectors = wfile_vectors concat <fit_a$i>
        }
        set fit_sort = fit_chi2
        sort <fit_sort fit_chi2>
        wfile $outdir"/datatable_cell_sigma_H68_function_fitting_chi2_sorted.txt"
        # 
        # write best-fit function parameters
        set fit_chi2 = fit_chi2[0]
        set fit_a0 = fit_a0[0]
        do i = 1, dimen(bin_pars) {
            set fit_a$i = fit_a$i[0]
        }
        define print_noheader 1
        print  $outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_a0 = %0.20g\n' <fit_a0>
        print +$outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_y = fit_a0\n' {}
        do i = 1, dimen(bin_pars) {
        print +$outdir"/datatable_cell_sigma_H68_function.txt" '\#set data_x$i = $(bin_pars[$i-1])\n' {}
        print +$outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_a$i = %0.20g\n' <fit_a$i>
        print +$outdir"/datatable_cell_sigma_H68_function.txt" 'set fit_y = fit_y / (data_x$i**fit_a$i)\n' {}
        }
        define print_noheader 0
        !cat $outdir"/datatable_cell_sigma_H68_function.txt"
    }
    # 
    # 
    # 
    # 
    # 
    # 
    # apply corrections
    if(1) {
        set MajBeam_uncorr0 = MajBeam
        set MajBeam = (MajBeam<0.25) ? 0.25 : MajBeam
        # 
        # 
        # 
        # correct (Xf-f)/Xf median
        do i = 1, dimen(bin_pars) {
            set data_x$i = $(bin_pars[$i-1])
        }
        input $outdir"/datatable_cell_median_function.txt"
        #--> output fit_y
        # 
        # 
        # 
        # derive flux density bias
        #     (Xf-f)/Xf = calc_bin_median
        # =>  Xf = f/(1-calc_bin_median)
        # =>  fbias = (Xf-f) = f*(1/(1-calc_bin_median)-1) = f * (calc_bin_median/(1-calc_bin_median))
        set fit_median = fit_y
        set fbias = f * (fit_y/(1-fit_y))
        set f = f + fbias
        # 
        # 
        # 
        # correct (Xf-f)/Xf sigma
        do i = 1, dimen(bin_pars) {
            set data_x$i = $(bin_pars[$i-1])
        }
        input $outdir"/datatable_cell_sigma_L68_function.txt"
        #--> output fit_y
        # 
        # derive flux density error
        #     (S_in - S_out) / S_in = sig
        # ..  (S_in - S_out) / err = 1.0
        # =>  err = S_in * sig
        # ..  S_out = S_in
        # =>  err = S_out * sig
        set fit_sigma_L68 = fit_y
        set ferr_L68 = f * (fit_y)
        # 
        # 
        # 
        # correct (Xf-f)/Xf sigma
        do i = 1, dimen(bin_pars) {
            set data_x$i = $(bin_pars[$i-1])
        }
        input $outdir"/datatable_cell_sigma_H68_function.txt"
        #--> output fit_y
        # 
        # derive flux density error
        #     (S_in - S_out) / S_in = sig
        # ..  (S_in - S_out) / err = 1.0
        # =>  err = S_in * sig
        # ..  S_out = S_in
        # =>  err = S_out * sig
        set fit_sigma_H68 = fit_y
        set ferr_H68 = f * (fit_y)
        # 
        # 
        # 
        # debug
        print $outdir"/debug_correction_function_fit_y.txt" '%15.0f %15g %15g %15g %15g %15g %15g\n' {id MajBeam fpeakSNR fit_median fit_sigma_L68 fit_sigma_H68}
        # 
        # 
        # 
        # set MajBeam back without lower limit of 0.25
        set MajBeam = MajBeam_uncorr0
        # 
        # 
        # 
        # print corrected f df
        set wfile_vectors = {id Xf f_uncorr0 f fbias ferr_L68 ferr_H68 cell_id snr_total fpeak noise fres Maj Min beam_maj beam_min sim_alma_image_STR sim_repetition_STR}
        load wfile.sm
        wfile $outdir"/datatable_corrected.txt"
    }
    
    
    
    
    exit
    # 
    # 
    # 
    # bin by Maj
    set MajBeam_BinEdges = {0.0 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 3.50 5.00}
    # 
    go_calc_bin_scatter ((MajBeam)) ((Xf-f)/Xf) ((MajBeam_BinEdges))
    go_plot_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{in}"
    go_save_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{in}"
    # 
    go_calc_bin_scatter ((MajBeam)) ((Xf-f)/f) ((MajBeam_BinEdges))
    go_plot_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{out}"
    go_save_bin_scatter "MajBeam" "(S_{in}-S_{out})/S_{out}"
    # 
    go_calc_bin_scatter ((MajBeam)) ((Xf-f)) ((MajBeam_BinEdges))
    go_plot_bin_scatter "MajBeam" "(S_{in}-S_{out})"
    go_save_bin_scatter "MajBeam" "(S_{in}-S_{out})"
    # 
    go_corr_by_param MajBeam
    # 
    # 
    # 
    # bin by fpeakSNR
    set fpeakSNR = fpeak/noise
    #set fpeakSNR_BinEdges = {2.0 2.5 3.0 3.5 4.0 4.5 5 6 7 8 9 10 20 100}
    set fpeakSNR_BinEdges = {2.0 2.5 3.0 3.5 4 5 7 10 20 100}
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((Xf-f)/Xf) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR" "(S_{in}-S_{out})/S_{in}"
    go_save_bin_scatter "peak_SNR" "(S_{in}-S_{out})/S_{in}"
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((Xf-f)/f) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR" "(S_{in}-S_{out})/S_{out}"
    go_save_bin_scatter "peak_SNR" "(S_{in}-S_{out})/S_{out}"
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((Xf-f)) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR" "(S_{in}-S_{out})"
    go_save_bin_scatter "peak_SNR" "(S_{in}-S_{out})"
    # 
    # correct by fpeakSNR
    go_corr_by_param fpeakSNR
    # 
    # 
    # 
    # bin by fpeakSNR and plot (S_{in}-S_{out,uncorr})/\sigma
    go_calc_bin_scatter ((fpeakSNR_uncorr0)) ((Xf-f_uncorr0)/df_uncorr0) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR (uncorr)" "(S_{in}-S_{out,uncorr})/\sigma_{uncorr}"
    go_save_bin_scatter "peak_SNR_uncorr" "(S_{in}-S_{out,uncorr})/\sigma_{uncorr}"
    # 
    go_calc_bin_scatter ((fpeakSNR)) ((Xf-f)/df) ((fpeakSNR_BinEdges))
    go_plot_bin_scatter "log peak SNR (corr)" "(S_{in}-S_{out,corr})/\sigma_{corr}"
    go_save_bin_scatter "peak_SNR_corr" "(S_{in}-S_{out,corr})/\sigma_{corr}"
    # 
    # 
    # 
    # bin by ftotalSNR
    set ftotalSNR = f/df
    #set ftotalSNR_BinEdges = {2.0 2.5 3.0 3.5 4.0 4.5 5 6 7 8 9 10 20 100}
    set ftotalSNR_BinEdges = {2.0 2.5 3.0 3.5 4 5 7 10 20 100}
    # 
    go_calc_bin_scatter ((ftotalSNR_uncorr0)) ((Xf-f_uncorr0)/Xf) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{in}"
    go_save_bin_scatter "total_SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{in}"
    # 
    go_calc_bin_scatter ((ftotalSNR)) ((Xf-f)/Xf) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (corr)" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "total_SNR (corr)" "(S_{in}-S_{out,corr})/S_{in}"
    # 
    go_calc_bin_scatter ((ftotalSNR_uncorr0)) ((Xf-f_uncorr0)/f_uncorr0) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    go_save_bin_scatter "total_SNR (uncorr)" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    # 
    go_calc_bin_scatter ((ftotalSNR)) ((Xf-f)/f) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (corr)" "(S_{in}-S_{out,corr})/S_{out,corr}"
    go_save_bin_scatter "total_SNR (corr)" "(S_{in}-S_{out,corr})/S_{out,corr}"
    # 
    go_calc_bin_scatter ((ftotalSNR_uncorr0)) ((Xf-f_uncorr0)) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (uncorr)" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "total_SNR (uncorr)" "(S_{in}-S_{out,uncorr})"
    # 
    go_calc_bin_scatter ((ftotalSNR)) ((Xf-f)) ((ftotalSNR_BinEdges))
    go_plot_bin_scatter "log total SNR (corr)" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "total_SNR (corr)" "(S_{in}-S_{out,corr})"
    # 
    # 
    # 
    # bin by S_{in} and other parameters
    go_calc_bin_scatter (lg(Xf)) ((Xf-f))
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})"
    # 
    go_calc_bin_scatter (lg(Xf)) ((Xf-f_uncorr0))
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})"
    # 
    go_calc_bin_scatter (lg(f)) ((Xf-f))
    go_plot_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})"
    # 
    go_calc_bin_scatter (lg(f_uncorr0)) ((Xf-f_uncorr0))
    go_plot_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})"
    #
    go_calc_bin_scatter (lg(Xf)) ((Xf-f)/Xf)
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,corr})/S_{in}"
    #
    go_calc_bin_scatter (lg(Xf)) ((Xf-f_uncorr0)/Xf)
    go_plot_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    go_save_bin_scatter "pow S_{in}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    #
    go_calc_bin_scatter (lg(f)) ((Xf-f)/Xf)
    go_plot_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "pow S_{out,corr}" "(S_{in}-S_{out,corr})/S_{in}"
    #
    go_calc_bin_scatter (lg(f_uncorr0)) ((Xf-f_uncorr0)/Xf)
    go_plot_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    go_save_bin_scatter "pow S_{out,uncorr}" "(S_{in}-S_{out,uncorr})/S_{out,uncorr}"
    # 
    # 
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((Xf/noise)) ((Xf-f_uncorr0)/Xf) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((Xf/noise)) ((Xf-f)/Xf) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((f_uncorr0/noise)) ((Xf-f_uncorr0)/Xf) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    go_save_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})/S_{in}"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((f/noise)) ((Xf-f)/Xf) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    go_save_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})/S_{in}"
    # 
    # 
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((Xf/noise)) ((Xf-f_uncorr0)) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    # 
    set SinRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((Xf/noise)) ((Xf-f)) ((SinRMS_BinEdges))
    go_plot_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "log S_{in}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((f_uncorr0/noise)) ((Xf-f_uncorr0)) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    go_save_bin_scatter "log S_{out,uncorr}/\sigma_{rms}" "(S_{in}-S_{out,uncorr})"
    # 
    set SoutRMS_BinEdges = {1.0 2.0 3.0 4 6 10 30 100}
    go_calc_bin_scatter ((f/noise)) ((Xf-f)) ((SoutRMS_BinEdges))
    go_plot_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    go_save_bin_scatter "log S_{out,corr}/\sigma_{rms}" "(S_{in}-S_{out,corr})"
    # 
    #go_calc_bin_scatter (lg(f)) ((Xf-f)/f)
    #go_plot_bin_scatter "pow S_{out}" "(S_{in}-S_{out})/S_{out}"
    #go_save_bin_scatter "pow S_{out}" "(S_{in}-S_{out})/S_{out}"
    # 
    # 
    # 
    check_outliers
    # 
    #plot_S_in_S_out
    #plot_S_in_S_out_versus_Param 1
    #plot_S_in_S_out_versus_Param 2
    #plot_S_in_S_out_versus_Param 3
    #plot_S_in_S_out_versus_Param Xf
    #plot_S_in_S_out_versus_Param Tf
    #plot_XfmTfEdf_versus_Param 1
    #plot_XfmTfEdf_versus_Param 2
    #plot_XfmTfEdf_versus_Param 3
    #plot_XfmTfEdf_versus_Param Xf
    #plot_XfmTfEdf_versus_Param Tf


















calc_mean_median 02
    # $1 is data array
    # $2 is sigma clip
    # output:
    #           calc_bin_mean
    #           calc_bin_median
    #           calc_bin_sigma
    if($?1) {
        set calc_bin_array = $1
        stats calc_bin_array calc_bin_array_mean calc_bin_array_sigma calc_bin_array_kurt
        stats_med calc_bin_array calc_bin_array_median calc_bin_array_siqr
        # 
        # apply sigma clip according to $2
        if($?2) {
            set calc_bin_array_clipped = calc_bin_array if(abs(calc_bin_array-$calc_bin_array_mean)<=float($2)*$calc_bin_array_sigma)
            stats calc_bin_array_clipped calc_bin_array_mean calc_bin_array_sigma calc_bin_array_kurt
            stats_med calc_bin_array_clipped calc_bin_array_median calc_bin_array_siqr
        }
        set calc_bin_mean = $calc_bin_array_mean
        set calc_bin_median = $calc_bin_array_median
        set calc_bin_sigma = $calc_bin_array_sigma
    }





calc_asymmetric_scatters 02
    # $1 is data array
    # $2 is sigma clip
    # output: 
    #           asym_bin_scatter_L68
    #           asym_bin_scatter_H68
    if($?1) {
        set asym_bin_array = $1
        vecminmax asym_bin_array asym_bin_array_min asym_bin_array_max
        stats asym_bin_array asym_bin_array_mean asym_bin_array_sigma asym_bin_array_kurtosis
        # 
        # apply sigma clip according to $2
        if($?2) {
            set asym_bin_array_clipped = asym_bin_array if(abs(asym_bin_array-$asym_bin_array_mean)<=float($2)*$asym_bin_array_sigma)
            stats asym_bin_array_clipped asym_bin_array_mean asym_bin_array_sigma asym_bin_array_kurtosis
        }
        # 
        # apply mean bias
        #set asym_bin_array = asym_bin_array - $asym_bin_array_mean
        # 
        # compute assymetic sigma
        if($asym_bin_array_min < $asym_bin_array_max) {
            set asym_bin_k = 0.0
            set asym_bin_scatter_H68 = 0.0
            while { asym_bin_k<=$asym_bin_array_max } {
                #set asym_bin_scatter_H68 = asym_bin_k
                if(sum(asym_bin_array>=0 && asym_bin_array<asym_bin_k) > sum(asym_bin_array>=0)*0.682689492137086) {
                    set asym_bin_scatter_H68 = asym_bin_k
                    break
                }
                set asym_bin_k = asym_bin_k + abs($asym_bin_array_sigma)/30.0
            }
            # check
            if(asym_bin_scatter_H68==0) {
                print '\nError! Failed to compute asym_bin_scatter_H68 by step $(abs($asym_bin_array_sigma)/30.0) from 0 to $asym_bin_array_max!\n' {}
                print {asym_bin_array}
            }
            # 
            set asym_bin_k = 0.0
            set asym_bin_scatter_L68 = 0.0
            while { asym_bin_k>=$asym_bin_array_min } {
                #set asym_bin_scatter_L68 = abs(asym_bin_k)
                if(sum(asym_bin_array<=0 && asym_bin_array>asym_bin_k) > sum(asym_bin_array<=0)*0.682689492137086) {
                    set asym_bin_scatter_L68 = abs(asym_bin_k)
                    break
                }
                set asym_bin_k = asym_bin_k - abs($asym_bin_array_sigma)/30.0
            }
            # check
            if(asym_bin_scatter_L68==0) {
                print '\nError! Failed to compute asym_bin_scatter_L68 by step $(abs($asym_bin_array_sigma)/30.0) from $asym_bin_array_min to 0!\n' {}
                print {asym_bin_array}
            }
        }
    }





go_calc_bin_scatter 03
    # 
    # analyze (S_in-S_out)/S_in agains xarray per bin
    set xArray = ($1)
    set yArray = ($2)
    set zArray = (Xf-f) # always compute (Xf-f) scatter
    vecminmax xArray xMin xMax
    if($?3) {
        set xBinEdges = ($3)
    } else {
        set xBinNumb = 10
        set xBinStep = ($xMax-$xMin)/float(xBinNumb)
        set xBinEdges = $xMin,$xMax+0.5*xBinStep,xBinStep
    }
    # 
    set xBinNumb = dimen(xBinEdges)-1
    # 
    declare xBinLower 0.f
    declare xBinUpper 0.f
    declare xBinValue 0.f
    declare yBinValue 0.f
    declare yBinError 0.f
    declare yBinErrLo 0.f
    declare yBinErrHi 0.f
    declare zBinValue 0.f
    declare zBinError 0.f
    declare zBinErrLo 0.f
    declare zBinErrHi 0.f
    declare xBinNumber 0.f
    do i=1,xBinNumb {
        if($i==xBinNumb) {
            set yBinArray = yArray if(xArray>=xBinEdges[$i-1] && xArray<=xBinEdges[$i])
            set zBinArray = zArray if(xArray>=xBinEdges[$i-1] && xArray<=xBinEdges[$i])
        } else {
            set yBinArray = yArray if(xArray>=xBinEdges[$i-1] && xArray<xBinEdges[$i])
            set zBinArray = zArray if(xArray>=xBinEdges[$i-1] && xArray<xBinEdges[$i])
        }
        if(dimen(yBinArray)>5) {
            #<TODO># make sure there are enough data points in a bin
            stats yBinArray yBinMean yBinSigma yBinKurt
            stats zBinArray zBinMean zBinSigma zBinKurt
            stats_med yBinArray yBinMedian yBinSIQR
            stats_med zBinArray zBinMedian zBinSIQR
            set yBinArray2 = yBinArray - $yBinMedian
            set zBinArray2 = zBinArray - $zBinMedian
            stats yBinArray2 yBinMean2 yBinSigma2 yBinKurt2
            stats zBinArray2 zBinMean2 zBinSigma2 zBinKurt2
            set xBinLower = xBinLower concat ((xBinEdges[$i-1]))
            set xBinUpper = xBinUpper concat ((xBinEdges[$i]))
            set xBinValue = xBinValue concat $((xBinEdges[$i]+xBinEdges[$i-1])/2.0)
            set yBinValue = yBinValue concat $yBinMedian
            set yBinError = yBinError concat $yBinSigma2
            set zBinValue = zBinValue concat $zBinMedian
            set zBinError = zBinError concat $zBinSigma2
            set xBinNumber = xBinNumber concat $(dimen(yBinArray))
            # 
            #vecminmax yBinArray2 yBinArray2Min yBinArray2Max
            #vecminmax zBinArray2 zBinArray2Min zBinArray2Max
            #echo Bin range $(xBinEdges[$i-1]) $(xBinEdges[$i]), yBinArray2 Min $yBinArray2Min Max $yBinArray2Max
            #set yBinArray3 = yBinArray2 if(abs(yBinArray2-$yBinMean2)<20.0*$yBinSigma2) # doClip
            calc_asymmetric_scatters yBinArray2
            set yBinErrHi = yBinErrHi concat asym_bin_scatter_H68
            set yBinErrLo = yBinErrLo concat asym_bin_scatter_L68
            # 
            #set zBinArray3 = zBinArray2 if(abs(zBinArray2-$zBinMean2)<20.0*$zBinSigma2) # doClip
            calc_asymmetric_scatters zBinArray2
            set zBinErrHi = zBinErrHi concat asym_bin_scatter_H68
            set zBinErrLo = zBinErrLo concat asym_bin_scatter_L68
        }
    }
    # 
    # set binVolume = {3 3 3 2 2 2 1 1 1 1}
    # load crabStat.sm
    # crabStat_vecBins (xArray) binVolume binCen binHis (yArray) MeanInBin MedianInBin SigmaInBin RMSInBin
    # set xBinNumb = dimen(binVolume)
    # set xBinEdges = fenBinEdges
    # set xBinValue = binCen
    # set yBinValue = MedianInBin
    # set yBinError = SigmaInBin
    # 


go_plot_bin_scatter 02
    # 
    define check_vectors 1
    foreach var {xBinEdges xBinValue yBinValue yBinError yBinErrLo yBinErrHi xBinNumber xArray yArray} {
        if(!is_vector($var)) {
            print 'Error! Vector $var does not exist!\n' {}
            define check_vectors 0
        }
    }
    if($check_vectors==0) {return}
    # 
    set xPlotStr = <$1> # $1 and $2 must be quoted by double-quotes
    set yPlotStr = <$2> # $1 and $2 must be quoted by double-quotes
    set xPlotArr = xArray # all data points
    set yPlotArr = yArray # all data points
    set xPlotEdg = xBinEdges
    set xPlotVar = xBinValue # bin average
    set yPlotVar = yBinValue # bin average
    set yPlotErr = yBinError # bin scatter
    set yPlotELo = yBinErrLo # bin scatter
    set yPlotEHi = yBinErrHi # bin scatter
    set xPlotLim = xPlotArr
    set yPlotLim = yPlotArr # (yPlotVar*1.5) concat (-yPlotVar*1.5)
    set xPlotTic = {0 0}
    set yPlotTic = {0 0}
    if(index(xPlotStr,'_SNR')>=0 || \
       index(xPlotStr,' SNR')>=0 || \
       index(xPlotStr,'S_{out}/\\sigma')>=0 || \
       index(xPlotStr,'S_{out,uncorr}/\\sigma')>=0 || \
       index(xPlotStr,'S_{out,corr}/\\sigma')>=0 || \
       index(xPlotStr,'S_{in}/\\sigma')>=0 ) { \
                                    set xPlotLim = {0.5 100} }
    if(index(xPlotStr,'log ')==0) { set xPlotArr = lg(xPlotArr)
                                    set xPlotVar = lg(xPlotVar)
                                    set xPlotEdg = lg(xPlotEdg)
                                    set xPlotStr = substr(xPlotStr,4,0)
                                    set xPlotLim = lg(xPlotLim)
                                    set xPlotTic = {-1 5} }
    if(index(yPlotStr,'log ')==0) { set yPlotArr = lg(yPlotArr)
                                    set yPlotErr = yPlotErr/yPlotVar*1.08
                                    set yPlotELo = yPlotELo/yPlotVar*1.08
                                    set yPlotEHi = yPlotEHi/yPlotVar*1.08
                                    set yPlotVar = lg(yPlotVar)
                                    set yPlotLim = lg(yPlotLim)
                                    set yPlotTic = {-1 10} }
    if(index(xPlotStr,'pow ')==0) { set xPlotTic = {-1 10}
                                    set xPlotStr = substr(xPlotStr,4,0) }
    if(index(yPlotStr,'pow ')==0) { set yPlotTic = {-1 10}
                                    set yPlotStr = substr(yPlotStr,4,0) }
    if(index(yPlotStr,'(S_{in}-S_{out})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out})/\\sigma')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,uncorr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,uncorr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,uncorr})/\\sigma')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,corr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,corr})/S_')==0) { set yPlotLim = {-4 4} }
    if(index(yPlotStr,'(S_{in}-S_{out,corr})/\\sigma')==0) { set yPlotLim = {-4 4} }
    # 
    !echo \\"Plot_$(yPlotStr)""_against_$(xPlotStr)"".eps\\" | sed -e 's/[^0-9a-zA-Z_.]/_/g' | perl -pe 's/[_]+/_/g' > .tmp.outname.txt
    verbose 0 data .tmp.outname.txt read outname 1.s
    verbose 1 !rm .tmp.outname.txt
    if(dimen(outname)==0) {set outname = 'go_plot_bin_scatter.eps'}
    if($?outdir) {set outname = '$outdir/'+outname}
    #echo outname = $(outname)
    # 
    load crabPlot.sm
    crabPlotOpenPS $(outname)
    location 6500 31500 18000 31500
    crabPlotDefaultPenForBox
    # 
    limits xPlotLim yPlotLim
    #limits xPlotLim yPlotArr
    ticksize $(xPlotTic[0]) $(xPlotTic[1]) $(yPlotTic[0]) $(yPlotTic[1])
    box
    # 
    crabPlotDefaultPenForTitle
    #xlabel $(xPlotStr)
    relocate $($fx1+0.50*($fx2-$fx1)) $($fy1-0.195*($fy2-$fy1))
    putlabel 5 $(xPlotStr)
    #ylabel $(yPlotStr)
    relocate $($fx1-0.165*($fx2-$fx1)) $($fy1+0.5*($fy2-$fy1))
    angle 90
    putlabel 5 $(yPlotStr)
    angle 0
    # 
    crabPlotDefaultPenForPoints
    ptype 4 1 expand 0.75 lweight 1.5
    points xPlotArr yPlotArr
    # 
    crabPlotDefaultPenForConnect
    ltype 1
    do igp=0,dimen(xPlotEdg)-1 {
        rel $(xPlotEdg[$igp]) $fy1
        draw $(xPlotEdg[$igp]) $fy2
    }
    rel $fx1 0 draw $fx2 0
    # 
    crabPlotDefaultPenForPoints
    expand 3.5
    ctype dodgerblue
    points xPlotVar yPlotVar
    #error_y xPlotVar yPlotVar yPlotErr
    errorbar xPlotVar yPlotVar yPlotELo 4
    errorbar xPlotVar yPlotVar yPlotEHi 2
    ctype default
    # 
    crabPlotClosePS
    !rm $outdir"/*.eps" 2>/dev/null
    !rm $outdir"/*.pdfmarks" 2>/dev/null
    !rm $outdir"/*.pdfconverts" 2>/dev/null


go_save_bin_scatter 03
    # 
    define check_vectors 1
    foreach var {xBinLower xBinUpper xBinValue yBinValue yBinError yBinErrLo yBinErrHi zBinValue zBinError zBinErrLo zBinErrHi xBinNumber} {
        if(!is_vector($var)) {
            print 'Error! Vector $var does not exist!\n' {}
            define check_vectors 0
        }
    }
    if($check_vectors==0) {return}
    # 
    set xPlotStr = <$1> # $1 and $2 must be quoted by double-quotes
    set yPlotStr = <$2> # $1 and $2 must be quoted by double-quotes
    set zPlotStr = '(S_{in}-S_{out})'
    set S_in_Str = 'S_{in}'
    set S_out_Str = 'S_{out}'
    set S_err_Str = 'S_{err}'
    # 
    if(index(xPlotStr,'pow ')==0) { set xPlotStr = substr(xPlotStr,4,0) }
    if(index(yPlotStr,'pow ')==0) { set yPlotStr = substr(yPlotStr,4,0) }
    # 
    !echo \\"Table_$(yPlotStr)""_against_$(xPlotStr)"".txt\\" | sed -e 's/[^0-9a-zA-Z_.]/_/g' | perl -pe 's/[_]+/_/g' > .tmp.outname.txt
    verbose 0 data .tmp.outname.txt read outname 1.s
    verbose 1 !rm .tmp.outname.txt
    if(dimen(outname)==0) {set outname = 'go_save_bin_scatter.txt'}
    if($?outdir) {set outname = '$outdir\"/\"'+outname}
    #echo outname = $(outname)
    # 
    define print_noheader 1
    set yPlotErrStr = 'Scatter'
    set yPlotELoStr = 'ScatterL68'
    set yPlotEHiStr = 'ScatterH68'
    set zPlotErrStr = '(S_in-S_out)_Scatter'
    set zPlotELoStr = '(S_in-S_out)_ScatterL68'
    set zPlotEHiStr = '(S_in-S_out)_ScatterH68'
    set xPlotLowerStr = 'Lower'
    set xPlotUpperStr = 'Upper'
    set xBinNumberStr = 'Number'
    print  $(outname) '\# %18s %20s %20s %30s %20s %20s %20s %20s %25s %25s %25s %20s\n' {xPlotLowerStr xPlotUpperStr xPlotStr yPlotStr yPlotErrStr yPlotELoStr yPlotEHiStr zPlotStr zPlotErrStr zPlotELoStr zPlotEHiStr xBinNumberStr}
    print +$(outname) '\# \n' {}
    print +$(outname) '%20g %20g %20g %30g %20g %20g %20g %20g %25g %25g %25g %20g\n' {xBinLower xBinUpper xBinValue yBinValue yBinError yBinErrLo yBinErrHi zBinValue zBinError zBinErrLo zBinErrHi xBinNumber}
    define print_noheader 0
    # 
    # 
    !echo \\"Data_$(yPlotStr)""_against_$(xPlotStr)"".txt\\" | sed -e 's/[^0-9a-zA-Z_.]/_/g' | perl -pe 's/[_]+/_/g' > .tmp.outname.txt
    verbose 0 data .tmp.outname.txt read outname 1.s
    verbose 1 !rm .tmp.outname.txt
    if(dimen(outname)==0) {set outname = 'go_save_bin_scatter_data.txt'}
    if($?outdir) {set outname = '$outdir\"/\"'+outname}
    #echo outname = $(outname)
    # 
    define print_noheader 1
    set idStr = 'id'
    load checkVectorSize.sm
    if(!checkVectorSize(id,xArray,yArray)) {exit}
    print  $(outname) '\# %18s %20s %20s %20s %20s %30s %20s\n' {idStr S_in_Str S_out_Str S_err_Str xPlotStr yPlotStr zPlotStr}
    print +$(outname) '\# \n' {}
    print +$(outname) '%20.0f %20g %20g %20g %20g %30g %20g\n' {id Xf f df xArray yArray zArray}
    define print_noheader 0



check_outliers
    set coo = ((Xf-f)/Xf > 0.3) && (fpeakSNR>10)
    set cid = id if(coo)
    print $outdir"/check_outliers.txt" '%.0f\n' {cid}
    
    # check highest fpeakSNR sources
    set coo = (fpeakSNR>100)
    if(sum(coo)>0) {
        set cid = id if(coo)
        set coo_fpeakSNR = fpeakSNR if(coo)
        set coo_sim_alma_image_STR = sim_alma_image_STR if(coo)
        sort {coo_fpeakSNR coo_sim_alma_image_STR cid}
        foreach var {coo_fpeakSNR coo_sim_alma_image_STR cid} { set $var = reverse($var) }
        print $outdir"/check_outliers_fpeakSNR_GT_100.txt" '%15.0f %15g   %s\n' {cid coo_fpeakSNR coo_sim_alma_image_STR}
    }
    
    # check highest fpeakSNR sources
    
    set coo_abs_Sdiff = abs((Xf-f)/Xf)
    set coo = (fpeakSNR>10 && coo_abs_Sdiff>1.0)
    if(sum(coo)>0) {
        set cid = id if(coo)
        set coo_fpeakSNR = fpeakSNR if(coo)
        set coo_Sdiff = (Xf-f)/Xf if(coo)
        set coo_alma_image_STR = sim_alma_image_STR if(coo)
        set coo_repetition_STR = sim_repetition_STR if(coo)
        sort {coo_fpeakSNR coo_Sdiff coo_alma_image_STR coo_repetition_STR cid}
        foreach var {coo_fpeakSNR coo_Sdiff coo_alma_image_STR coo_repetition_STR cid} { set $var = reverse($var) }
        print $outdir"/check_outliers_fpeakSNR_GT_10_and_coo_abs_Sdiff_GE_1.txt" '%15.0f %15g %15g %40s   %-14s\n' {cid coo_fpeakSNR coo_Sdiff coo_alma_image_STR coo_repetition_STR}
    }



go_corr_by_param 01
    # 
    # check
    if(!$?1) {print 'Error! \$1 is not given!\n' {} exit}
    if(!$?outdir) {print 'Error! \$outdir is not defined!\n' {} exit}
    if(!is_vector(fpeak)) {print 'Error! fpeak is not set!\n' {} exit}
    if(!is_vector(f)) {print 'Error! f is not set!\n' {} exit}
    if(!is_vector(df)) {print 'Error! df is not set!\n' {} exit}
    if(!is_vector(Maj)) {print 'Error! Maj is not set!\n' {} exit}
    if(!is_vector(beam_maj)) {print 'Error! beam_maj is not set!\n' {} exit}
    # 
    # correct by param
    if('$1' == 'MajBeam') {
        data $outdir"/Table_S_in_S_out_S_in_against_MajBeam.txt"
    }
    if('$1' == 'fpeakSNR') {
        data $outdir"/Table_S_in_S_out_S_in_against_peak_SNR.txt"
    }
    read {X_Param 3 X_Bias 4 X_ScatterL68 6 X_ScatterH68 7}
    set Y_Param = ($1)
    vecminmax X_Param X_Param_Min X_Param_Max
    define X_Bias_IMin 0
    define X_Bias_IMax $(dimen(X_Bias)-1)
    interp2 X_Param X_Bias Y_Param Y_Bias
    interp2 X_Param X_ScatterL68 Y_Param Y_ScatterL68
    interp2 X_Param X_ScatterH68 Y_Param Y_ScatterH68
    set Y_Bias = (Y_Param<$X_Param_Min) ? X_Bias[$X_Bias_IMin] : Y_Bias # deal with interpolation at the edges, for flux bias
    set Y_Bias = (Y_Param>$X_Param_Max) ? X_Bias[$X_Bias_IMax] : Y_Bias # deal with interpolation at the edges, for flux bias
    # 
    set fpeak_uncorr = fpeak
    set fpeak_corr = fpeak_uncorr / (1 - Y_Bias)
    set fpeak = fpeak_corr
    # 
    set f_uncorr = f
    set f_corr = f_uncorr / (1 - Y_Bias)
    set f = f_corr
    # 
    set Y_Scatter = (Y_ScatterL68>Y_ScatterH68) ? Y_ScatterL68 : Y_ScatterH68 
    # (S_in - S_out) / S_in = Y_Scatter
    # (S_in - S_out) / err = 1.0
    # err / S_in = Y_Scatter
    # assuming S_out = S_in
    # so err = S_out * Y_Scatter
    set df_uncorr = df
    set df_corr = f_corr * Y_Scatter
    set df = df_corr














