#!/bin/bash
# 

if [[ $(type topcat | wc -l) -eq 0 ]]; then
    echo "Error! Topcat was not found!"
    exit
fi

use_Gaussian=1
str_Date=$(date +"%Y-%m-%d") # "2017-12-10" # "2018-01-06" # 
str_Fit="fit_2"
str_Type="Gaussian"

# Usage
if [[ $# -eq 0 ]]; then
    echo "Usage: "
    echo "  This code will combine \"Read_Results_all_final_\"*.txt files which are produced by our prior fitting pipeline."
    echo "  To run this code, please choose these options:"
    echo "  $(basename ${BASH_SOURCE[0]}) -date 2018-01-06 -gaussian"
    echo "  $(basename ${BASH_SOURCE[0]}) -date 2018-01-06 -gaussian -negative"
    echo "  $(basename ${BASH_SOURCE[0]}) -date 2018-01-06 -sersic -negative"
    exit
fi

# Read user-input date
i=1
while [[ i -le $# ]]; do
    str_Cmd=$(echo "${!i}" | tr '[:upper:]' '[:lower:]' | sed -e 's%^--%-%g')
    if [[ "${str_Cmd}" == "-date" ]]; then
        i=$((i+1))
        if [[ i -le $# ]]; then
            str_Date="${!i}"
        fi
    elif [[ "${str_Cmd}" == "-gaussian" ]]; then
        str_Fit=$(echo "${str_Fit}" | perl -p -e 's%(fit_)([n]*)([0-9]+)$%${1}${2}2%g')
        str_Type=$(echo "${str_Type}" | perl -p -e 's%(negative_)*([a-zA-Z]+)$%${1}Gaussian%g')
    elif [[ "${str_Cmd}" == "-sersic" ]]; then
        str_Fit=$(echo "${str_Fit}" | perl -p -e 's%(fit_)([n]*)([0-9]+)$%${1}${2}3%g')
        str_Type=$(echo "${str_Type}" | perl -p -e 's%(negative_)*([a-zA-Z]+)$%${1}Sersic%g')
    elif [[ "${str_Cmd}" == "-original" ]]; then
        str_Fit=$(echo "${str_Fit}" | perl -p -e 's%(fit_)([n]*)([0-9]+)$%${1}${3}%g')
        str_Type=$(echo "${str_Type}" | perl -p -e 's%(negative_)*([a-zA-Z]+)$%${2}%g')
    elif [[ "${str_Cmd}" == "-negative" ]]; then
        str_Fit=$(echo "${str_Fit}" | perl -p -e 's%(fit_)([n]*)([0-9]+)$%${1}n${3}%g')
        str_Type=$(echo "${str_Type}" | perl -p -e 's%(negative_)*([a-zA-Z]+)$%negative_${2}%g')
    fi
    i=$((i+1))
done
echo "Reading ${str_Fit} results and output ${str_Type}!"
#exit

# convert the data table, delete columns, convert all flux units to Jy or Jy/beam, and angular size units to degrees.
if [[ $use_Gaussian -eq 1 ]]; then
    topcat -stilts tmatchn \
                nin=3 \
                in1="Read_Results_all_final_${str_Fit}.result.all.txt" \
                ifmt1=ascii \
                values1="index" \
                in2="Read_Results_all_final_${str_Fit}.result.source_err.txt" \
                ifmt2=ascii \
                values2="index" \
                in3="Read_Results_all_final_${str_Fit}.result.source_area.txt" \
                ifmt3=ascii \
                values3="index" \
                matcher=exact \
                ofmt=fits \
                ocmd="select \"(flag_buffer==0)\"" \
                ocmd="addcol ID \"id_${str_Fit}_str\"" \
                ocmd="addcol RA \"ra_${str_Fit}\"" \
                ocmd="addcol Dec \"dec_${str_Fit}\"" \
                ocmd="addcol Total_flux -units \"Jy\" \"f\"" \
                ocmd="addcol E_Total_flux -units \"Jy\" \"source_total_err\"" \
                ocmd="addcol Galfit_flux -units \"Jy\" \"f_${str_Fit}/1e3\"" \
                ocmd="addcol E_Galfit_flux -units \"Jy\" \"df_${str_Fit}/1e3\"" \
                ocmd="addcol Peak_flux -units \"Jy\" \"source_peak\"" \
                ocmd="addcol E_Peak_flux -units \"Jy\" \"source_peak_err\"" \
                ocmd="addcol Residual_flux -units \"Jy\" \"fres_${str_Fit}/1e3\"" \
                ocmd="addcol Total_RMS -units \"Jy/beam\" \"rms_${str_Fit}/1e3\"" \
                ocmd="addcol Peak_RMS -units \"Jy/beam\" \"rms_${str_Fit}/1e3/sqrt(source_area_in_pix)\"" \
                ocmd="addcol RMS -units \"Jy/beam\" \"Peak_RMS\"" \
                ocmd="addcol Total_SNR \"Total_flux/E_Total_flux\"" \
                ocmd="addcol Peak_SNR \"Peak_flux/Peak_RMS\"" \
                ocmd="addcol Maj_deconv -units \"degrees\" \"maj_${str_Fit}/3600.0\"" \
                ocmd="addcol E_Maj_deconv -units \"degrees\" \"maj_err_${str_Fit}/3600.0\"" \
                ocmd="addcol Min_deconv -units \"degrees\" \"min_${str_Fit}/3600.0\"" \
                ocmd="addcol E_Min_deconv -units \"degrees\" \"min_err_${str_Fit}/3600.0\"" \
                ocmd="addcol PA_deconv -units \"degrees\" \"PA_${str_Fit}/3600.0\"" \
                ocmd="addcol E_PA_deconv -units \"degrees\" \"PA_err_${str_Fit}/3600.0\"" \
                ocmd="addcol Pixel_noise -units \"Jy/beam\" \"pix_noise\"" \
                ocmd="addcol Pixel_scale -units \"arcsec/pixel\" \"pix_scale\"" \
                ocmd="addcol Beam_area -units \"square-arcsec\" \"beam_area\"" \
                ocmd="addcol Obs_frequency -units \"GHz\" \"obs_freq\"" \
                ocmd="addcol Obs_wavelength -units \"um\" \"obs_lambda\"" \
                ocmd="addcol Pb_corr_pb_image \"pbcorr\"" \
                ocmd="addcol Pb_corr_equation \"pb_corr\"" \
                ocmd="addcol Galfit_chi_square \"chisq\"" \
                ocmd="addcol Galfit_reduced_chi_square \"rchisq\"" \
                ocmd="addcol Galfit_N_aperture_pixel \"n_aperpix\"" \
                ocmd="addcol Galfit_N_free_parameter \"n_freepar\"" \
                ocmd="addcol Flag_size_lower_boundary \"(abs(maj_${str_Fit}-1.0*pix_scale)<0.02)\"" \
                ocmd="addcol Flag_size_upper_boundary \"(abs(maj_${str_Fit}-3.0)<0.02)\"" \
                ocmd="addcol Flag_size_initial_guess \"(abs(maj_${str_Fit}-0.25)<0.02)\"" \
                ocmd="addcol Flag_zero_galfit_flux_error \"(df_${str_Fit}==0)\"" \
                ocmd="addcol Flag_zero_galfit_size_error \"(maj_${str_Fit}>0 && maj_err_${str_Fit}==0)\"" \
                ocmd="addcol Image_file_name \"image_file_1\"" \
                ocmd="addcol Image \"matches(image_file_1,\\\"(.*).cut_.*_.*_.*_.*\\\") ? matchGroup(image_file_1,\\\"(.*).cut_.*_.*_.*_.*\\\")+\\\".fits\\\" : image_file_1+\\\".fits\\\"\"" \
                out="A-COSMOS_prior_${str_Date}_${str_Type}_All_columns.fits"
                # http://www.star.bristol.ac.uk/~mbt/stilts/sun256/tmatchn-usage.html
                # 
                # converts all units to Jy, Jy/beam.
                # 
                # note: rms = pixnoise * fluxconv
                # 
    # 
    echo "Output to \"A-COSMOS_prior_${str_Date}_${str_Type}_All_columns.fits\"!"
    # 
    topcat -stilts tpipe \
                in="A-COSMOS_prior_${str_Date}_${str_Type}_All_columns.fits" \
                cmd="keepcols \"ID RA Dec Total_flux E_Total_flux Galfit_flux E_Galfit_flux Peak_flux E_Peak_flux Residual_flux Total_RMS Peak_RMS RMS Total_SNR Peak_SNR Maj_deconv E_Maj_deconv Min_deconv E_Min_deconv PA_deconv E_PA_deconv Pixel_noise Pixel_scale Beam_area Obs_frequency Obs_wavelength Pb_corr_pb_image Pb_corr_equation Galfit_chi_square Galfit_reduced_chi_square Galfit_N_aperture_pixel Galfit_N_free_parameter Flag_size_lower_boundary Flag_size_upper_boundary Flag_size_initial_guess Flag_zero_galfit_flux_error Flag_zero_galfit_size_error Image_file_name Image\"" \
                out="A-COSMOS_prior_${str_Date}_${str_Type}.fits"
    # 
    echo "Output to \"A-COSMOS_prior_${str_Date}_${str_Type}.fits\"!"
    # 
    topcat -stilts tpipe \
                in="A-COSMOS_prior_${str_Date}_${str_Type}.fits" \
                cmd="select (Total_flux/E_Total_flux>=3.0)" \
                out="A-COSMOS_prior_${str_Date}_${str_Type}_SNR_GE_3.fits"
    # 
    echo "Output to \"A-COSMOS_prior_${str_Date}_${str_Type}_SNR_GE_3.fits\"!"
fi





